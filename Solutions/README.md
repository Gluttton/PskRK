Set of solutions of the problem of finding binary sequences with low PSL level
==============================================================================
 - [01](01) - canonical solution implemented on C++:
    - optimization: none;
    - portability:  C++11;
    - build:        make;
    - contribution: none.
 - [02](02) - minimalistic solution implemented on pure C:
    - optimization:
        - skipped inverse-time sequences;
        - using lookup table for calculate number of bits.
    - portability:  C11;
    - build:        make;
    - contribution: none.
 - [03](03) - minimalistic solution implemented on C with inline assembly;
    - optimization:
        - multithreading;
        - skipped inverse-time sequences;
        - skipped sequences based on the already calculated sidelobe level of current sequence.
    - portability:  C++11;
    - build:        cmake;
    - contribution:
        - version 6b7fa8fa499df80824719e8a9b91ab7f062015b8 was used to proving sequences with length from 2 up to 13;
        - version 94bdafaabff628a155202d223ae583bd09f1604b was used to finding and proving sequences with length from 28 up to 47;
        - version 94bdafaabff628a155202d223ae583bd09f1604b with manually defined PSL limit 3 was used to finding and proving sequences with length 48;
        - version 1a8ce91075600206622a40c10419653bee9ee62b was used to finding and proving sequences with length 49 and took about 3.25 days on Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz.
        - version 6aaa9b65fb8e3312e0947b1828501b396940ee11 was used to finding and proving sequences with length 50 and took about 5.55 days on Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz.
        - version 0ba60c98b2ee8ba25dd777486399a5fc0f4083d3 was used to finding and proving sequences with length 51 and took about 8.15 days on Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz.
 - [04](04) - yet another solution implemented on C++, the main idea is try to use optimization based on reusing of partial sum of convolution:
    - optimization:
        - skipped inverse-time sequences;
        - abort calculation of sidelobe level for specific shift using current partially sum;
        - reusing of partial sum of convolution;
        - skipped sequences based on the already calculated sidelobe level of current sequence with sertain shift.
    - portability:  C++11;
    - build:        make;
    - contribution: none.
 - [07](07) - minimalistic solution implemented on C++ with `std::bitset` as storage of sequences:
    - optimization: none;
    - portability:  C++11;
    - build:        make;
    - contribution: none.
 - [08](08) - another implemented on C++ with `std::bitset` as storage of sequences and with random sequence generator:
    - optimization:
        - multithreading;
        - skipped inverse-time sequences.
    - portability:  C++11;
    - build:        make;
    - contribution: none.
        - version c94f282d1a1e4d10c62d23dce8a17d5cfd6187f6 was used to finding and proving one sequence with length 52 and took about 20 seconds on Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz.

